<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: development | Working thoughts]]></title>
  <link href="https://lplotni.github.io/blog/categories/development/atom.xml" rel="self"/>
  <link href="https://lplotni.github.io/"/>
  <updated>2015-10-15T12:18:41+02:00</updated>
  <id>https://lplotni.github.io/</id>
  <author>
    <name><![CDATA[Lukasz Plotnicki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pace: testing an express app]]></title>
    <link href="https://lplotni.github.io/blog/2015/10/10/express-testing/"/>
    <updated>2015-10-10T07:29:20+02:00</updated>
    <id>https://lplotni.github.io/blog/2015/10/10/express-testing</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/test_pyramid.jpg" width="400" height="300" title="Test pyramid" >
After we managed to set up our basic <a href="/blog/2015/08/04/bootstraping-a-node-dot-js-webapp/">web application</a>,
let&rsquo;s get our
hands dirty writing some code. And as we want to do it in a test-driven
manner (<a href="http://martinfowler.com/bliki/TestDrivenDevelopment.html">TDD</a>), we need
a proper test setup. This piece is all about our initial test pyramid. Test,
what? Yes, pyramid:</p>

<p><blockquote><p>At the base of the test automation pyramid is unit testing. Unit testing should<br/>be the foundation of a solid test automation strategy and as such represents<br/>the largest part of the pyramid. (&hellip;) Automated user interface testing is<br/>placed at the top of the test automation pyramid because we want to do as<br/>little of it as possible. (&hellip;) Testing through the user interface like this is<br/>expensive and should be minimized. Although there are many test cases that need<br/>to be invoked, not all need to be run through the user interface. And this is<br/>where the service layer of the test automation pyramid comes in.</p><footer><strong>Mike Cohn <a href="https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid</a></strong></footer></blockquote></p>

<p>Depending on your personal style (look at this
<a href="http://martinfowler.com/bliki/TestPyramid.html">post</a> by Martin Fowler for
more details around different <em>flavours</em> of unit testing) and probably also the
task at hand, you will either be starting with a unit test or
acceptance/functional test. The rest of this post will show you how to set up
each kind of test and give you a brief description of what we mean by saying
<strong>unit</strong>, <strong>integration</strong> and <strong>functional</strong> test. I will also describe our
<strong>gulp setup</strong>.</p>

<!-- more -->


<h2>Unit test</h2>

<p>In JavaScript and node.js world your are spoiled for choices in regards to
your unit tests libraries and runners: Jasmine, Mocha and friends, just pick
one. We decided to go with
<a href="https://jasmine.github.io/2.3/introduction.html">Jasmine</a>, in which a test
looks like this:</p>

<pre><code class="javascript">/* jshint node: true */
/* global describe, beforeEach, afterEach, it, jasmine, expect */
'use strict';
describe('exractParticipant', function () {
  var extractParticipant;
  var validRequestData = {
    body: {
      firstname: 'Mark',
      lastname: 'Mueller',
      email: 'm.mueller@example.com'
    }
  };

  beforeEach(function () {
    extractParticipant= require('../routes/registration.js').extractParticipant
  });

  it('should read firstname from the request body', function() {
    expect(extractParticipant(validRequestData).firstname).toBe('Mark');
  });

  it('should throw an error if no firstname can be found', function () {
    function callWithNoFirstname() {
      extractParticipant({body: {}});
    }

    expect(callWithNoFirstname).toThrow();
  });
}
</code></pre>

<p>Here we are verifying the behavior of the <code>extractParticipant()</code> function
which given a request body returns a specific JS object. We can use multiple
 <code>describe</code> calls, or even nested <code>describe</code> calls to cluster the
tested functionality. Each <code>it</code> call corresponds with a specific behaviour
we want to verify. <strong>Jasmine</strong> provides matchers and spies to simplify our
testing: Just look at the
<a href="https://jasmine.github.io/2.3/introduction.html">reference</a> to see what&rsquo;s
possible.  Generally it&rsquo;s a good practice to verify one specific aspect per
test. Any other recommendations, you ask <img alt="sunglasses" src="/images/emoji/unicode/1f60e.png" class="emoji" /> A good unit test
is:</p>

<ul>
<li><strong>fast</strong>: All the unit tests will be executed very often, therefore it&rsquo;s
necessarry that their execution happens in ms</li>
<li><strong>atomic</strong>: The unit tests should be independant from one-another, so that you can
run them parallel. This means that they should not relay on any side
effects (data modifications done by other tests etc.). It&rsquo;s also way easier
to reason why a certain test is red, if all you need to care about is only
the scope of that particular test.</li>
</ul>


<p>As usual Martin Fowler wrote a nice <a href="http://martinfowler.com/bliki/UnitTest.html">bliki about unit tests</a>.</p>

<h2>Integration test</h2>

<p>As the name already states, an integration test verifies the behaviour of
a group of components of our software acting together. Look at the following
test, which checks the intgeration between a service and the database:</p>

<pre><code class="javascript">'use strict';
/* jshint node: true */
/* jshint esnext: true */
/* global describe, beforeEach, afterAll, it, jasmine, expect */

describe('participants service', function () {

    const participants = require('../../service/participants');
    var pg = require('pg');

    beforeEach(function (done) {
        var connectionString = process.env.SNAP_DB_PG_URL || "tcp://vagrant@localhost/pace";
        var jasmineDone = done;

        pg.connect(connectionString, function (err, client, done) {
                client.query('delete from participants', function () {
                    done();
                    jasmineDone();
                });
            }
        );

    });

    afterAll(function(done) {
        pg.end();
        done();
    });


    it('should store and read participants', function (done) {
        var aParticipant = {
            firstname: 'Hertha',
            lastname: 'Mustermann',
            email: 'h.mustermann@example.com'
        };

        participants.save(aParticipant)
            .then(participants.getAll)
            .then(function (data) {
                expect(data.length).toBe(1);
                expect(data[0].firstname).toBe(aParticipant.firstname);
                expect(data[0].lastname).toBe(aParticipant.lastname);
                expect(data[0].email).toBe(aParticipant.email);
                done();
            });
    });
});
</code></pre>

<p>The integration test is similiar to the unit one (it&rsquo;s also based on jasmine),
but instead of mocking our dependencies we use the real implementation (here
the <code>pg</code> PostgreSQL client) and verify the integration of both components.
In this particular example, we store a participant and expect that if we call
the <code>getAll</code> function, it will be returned in the correct form. As the
test will actually store objects in the dabase, we need to assure that before
we execute the test, the database is cleared. This is done in the
 <code>beforeEach</code> method. You may ask &lsquo;why before the test and not afterwards&rsquo;:
In case of an error, we will still have the possibility to check the state of
the database.</p>

<p>As we need to connect to the database and assure a particular state before
each test run, those tests will always be slower than the unit ones. Therefore
we should try to test only the integrational aspects in them and everything
else on the unit level. In the end we are not interested in a test suite for
a 3rd party component, but only a verification of the fact that our usage of
it is correct.</p>

<h2>Functional test</h2>

<p>Whenever we test the system as a whole, we talk about functional tests.
Typically those tests go against an outer-most interface of our app, often
the UI. In our case we will interact with pace via its web page.
To do that, we use <a href="http://webdriver.io/">WebDriverIO</a> on top of <a href="http://docs.seleniumhq.org/">selenium</a> and a headless browser called <a href="http://phantomjs.org/">phantomjs</a>. This combination offers an easy to use API for browser-interaction.</p>

<pre><code class="javascript">/* jshint node: true */
/* global describe, beforeEach, afterEach, it, jasmine, expect */
'use strict';
describe('regisitration journey', function () {
    var client;
    var paceUrl = process.env.PACE_URL || 'http://localhost:3000/';
    var originalTimeout;

    beforeEach(function () {
        var webdriverio = require('webdriverio');
        var options = {
            desiredCapabilities: {
                browserName: 'phantomjs'
            }
        };

        client = webdriverio.remote(options);
        originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
        jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;
    });

    afterEach(function () {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;
    });

    it('allows to register via the registration page', function (done) {

        client.init()
            .url(paceUrl)
            .click('a#registration')
            .setValue('input#firstname', 'Max')
            .setValue('input#lastname', 'Mustermann')
            .setValue('input#email', 'max@example.com')
            .setValue('input#gender', 'Unicorn')
            .click('button#submit')
            .isVisible('div.thanks')
            .then(function (isVisible) {
                expect(isVisible).toBe(true);
                done();
            })
            .end();
    });

});
</code></pre>

<p>First we need to setup the webdriver client to use the proper pace base url and
browser. We also change the default jasmine timeout for async tests, as in
general the browser based interactions tend to take more time. After that it is
pretty straightforward: We click on a link, type into input fields, submit
the form and verify that we land on the success page (look at
<a href="http://webdriver.io/api.html">webdriverio API</a> for all the different interactions
one can trigger). This is the happy path of our registration journey and as the
functional test are the most expensive ones (in regards to the execution time),
we will try to stick only to happy-path testing on this level.</p>

<h2>Test execution</h2>

<p>Ok, so how can you run all the tests in a convenient way? Pace uses <a href="http://gulpjs.com/">gulp</a> to build and automate a lot of stuff. Here are the important commands and convention:</p>

<ul>
<li>All tests (specs) should be places in the <strong>/spec</strong> directory</li>
<li>All integration tests must have &lsquo;<strong>IT</strong>&rsquo; in their filename</li>
<li>All functional tests must have &lsquo;<strong>Journey</strong>&rsquo; in their filename</li>
<li><code>gulp test</code> - runs all the unit tests</li>
<li><code>gulp test-integration</code> - runs all the integration tests, depends on
existing database</li>
<li><code>gulp test-functional</code> - runs all functional tests, depends on installed
selenium-server and drivers</li>
</ul>


<p>To simplify the setup of a dev box, pace offers one simple command:</p>

<ul>
<li><code>gulp dev-setup</code> - prepares the vagrant box with the databse, installs
all dependencies for selenium and executes the database migrations</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pace: Starting with node & express]]></title>
    <link href="https://lplotni.github.io/blog/2015/08/04/bootstraping-a-node-dot-js-webapp/"/>
    <updated>2015-08-04T16:52:53+02:00</updated>
    <id>https://lplotni.github.io/blog/2015/08/04/bootstraping-a-node-dot-js-webapp</id>
    <content type="html"><![CDATA[<p>Together with few friends we started building <strong><a href="https://github.com/lplotni/pace">pace</a></strong> - a web application for
organizing and managing running events &amp; competitions. We are a colorful bunch of people with different backgrounds, therefore we wanted to choose an approachable tech stack, as some of us wants also to learn one or two things about <strong>JavaScript</strong>, <strong>web applications</strong> or <strong>programming</strong> in general.</p>

<p>And then, somebody suggested to write one thing or two, about our technology
decisions and accompany it with some <em>HowTo</em> information. So here we are.</p>

<!-- more -->


<p>This is the first post out of the <strong>pace</strong> series. We will take a look at how to quickly bootstrap a new express.js application and what is acctually happening during that process.</p>

<h2>First things first: node.js &amp; express.js</h2>

<p><blockquote><p>Node.js® is a platform  built on Chrome&rsquo;s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p><footer><strong>Nodejs.org <a href="https://nodejs.org">https://nodejs.org</a></strong></footer></blockquote></p>

<p>Probably also due to the popularity of JavaScript <a href="https://nodejs.org/">node</a> quickly spread all around the web and is nowadays widely <a href="https://github.com/joyent/node/wiki/projects,-applications,-and-companies-using-node">used</a> and has an impressive ecosystem of additional libraries/modules (just take a look at <a href="https://www.npmjs.com/">npm package manager</a>).</p>

<p><a href="http://expressjs.com/">express.js</a> is one of many web frameworks based on node, but seems also to be one of the most popular ones. What is a web framework you ask:</p>

<p><blockquote><p>A web application framework is a software framework that is designed to support the development of dynamic websites, web applications, web services and web resources. The framework aims to alleviate the overhead associated with common activities performed in web development. For example, many frameworks provide libraries for database access, templating frameworks and session management, and they often promote code reuse</p><footer><strong>Wikipedia <a href="https://en.wikipedia.org/wiki/Web_application_framework">https://en.wikipedia.org/wiki/Web_application_framework</a></strong></footer></blockquote></p>

<h3>How to bootstrap a web app &amp; what happens</h3>

<p>Assuming you have node already installed on your machine (if not look at <a href="https://nodejs.org/download/">here</a>)</p>

<pre><code class="bash">npm install express-generator -g
express myWebApp
cd myWebApp
npm install
npm start
</code></pre>

<p>What happened you ask? So first we globally installed <a href="https://www.npmjs.com/package/express-generator">express-generator</a> (it will be now available to you via <em>express</em> cmd). Then we made it bootstrap for us an app called <em>myWebApp</em>. This resulted in the following:</p>

<pre><code class="bash">/tmp|⇒ express myWebApp

   create : myWebApp
   create : myWebApp/package.json
   create : myWebApp/app.js
   create : myWebApp/public
   create : myWebApp/public/javascripts
   create : myWebApp/public/images
   create : myWebApp/routes
   create : myWebApp/routes/index.js
   create : myWebApp/routes/users.js
   create : myWebApp/public/stylesheets
   create : myWebApp/public/stylesheets/style.css
   create : myWebApp/views
   create : myWebApp/views/index.jade
   create : myWebApp/views/layout.jade
   create : myWebApp/views/error.jade
   create : myWebApp/bin
   create : myWebApp/bin/www

   install dependencies:
     $ cd myWebApp &amp;&amp; npm install

   run the app:
     $ DEBUG=myWebApp ./bin/www
</code></pre>

<p>The generator created for us a new directory which contains all the needed files the web application consists of:</p>

<ul>
<li><strong>package.json</strong> -> definition of our node dependencies and some node configuration</li>
<li><strong>app.js</strong> -> the main entry point into the application</li>
<li><strong>public</strong> -> contains all public assets whic will be exposed to the public</li>
<li><strong>routes</strong> -> contains the definitions of our routes (as ourDomain/index or ourDomain/somethingDifferent)</li>
<li><strong>views</strong> -> contains our templates (more about this in future posts)</li>
<li><strong>bin/www</strong> -> executable application (if you run <code>npm start</code> this will be started)</li>
</ul>


<p>The execution of <code>npm install</code> in app&rsquo;s directory, installs all the dependencies defined in the <code>package.json</code> file. Those dependencies will be installed only locally in the <code>node_modules</code> directory. After this step we are ready to go and able to run <code>npm start</code> which should result in this:</p>

<pre><code class="bash">myWebApp|⇒ npm start

&gt; myWebApp@0.0.1 start /private/tmp/myWebApp
&gt; node ./bin/www

GET / 200 305ms - 170b
GET / 200 34ms - 170b
GET /stylesheets/style.css 200 4ms - 110b
GET / 304 25ms
GET /stylesheets/style.css 304 1ms
</code></pre>

<p>You can see, that I opened <a href="http://localhost:3000">http://localhost:3000</a> in the browser and express served me the index page with the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">200 code</a> (you can also see that I refreshed the page and got 304 NOT MODIFIED). Everything works also as expected <img alt="+1" src="/images/emoji/unicode/1f44d.png" class="emoji" /></p>

<p><strong>Why? How?</strong> Let&rsquo;s take a quick look at the following:</p>

<pre><code class="JavaScript app.js">var routes = require('./routes/index');

app.use('/', routes)
</code></pre>

<p>This is only a part of the <code>app.js</code> file but shows the wiring of our default root to the index.js file shown below. BTW: you can also see how to load dependencies/modules for our code via the <code>require</code> function (if you want to read more about that, <a href="http://openmymind.net/2012/2/3/Node-Require-and-Exports/">here is a nice write-up</a>)</p>

<pre><code class="JavaScript routes/index.js">var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res) {
  res.render('index', { title: 'Express' });
});

module.exports = router;
</code></pre>

<p>The <code>index.js</code> uses express' <code>router</code> and wires request for <strong>/</strong> to the function responding with a rendered <code>index.jade</code> template, to which it passes a variable called <code>title</code>. If you never used <a href="http://jade-lang.com/">jade</a>, don&rsquo;t worry, is a pretty simple HTML template engine. Look at the following:</p>

<pre><code class="jade index.jade">extends layout

block content
  h1= title
  p Welcome to #{title}
</code></pre>

<p>Jade enables template composition. In here we extend <code>layout.jade</code> which defines the general page structure. If other template defines a <strong>block</strong> called <code>content</code> it will be then injected at the corresponding place.</p>

<pre><code class="jade layout.jade">doctype html
html
  head
    title= title
    link(rel='stylesheet', href='https://lplotni.github.io/stylesheets/style.css')
  body
    block content
</code></pre>

<p>Jade is indentation aware, meaning that the above example results in the following:</p>

<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Express&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://lplotni.github.io/stylesheets/style.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Express&lt;/h1&gt;
    &lt;p&gt;Welcome to Express&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Now you have seen all the parts making the browser render the most basic page of all time <img alt="sunglasses" src="/images/emoji/unicode/1f60e.png" class="emoji" /></p>

<p>Next post out of the <strong>pace</strong> series, will actually explain how to start working on the functionality we need. Right now you can start to play around with the data which is passed by the <code>index.js</code> to the <code>index.jade</code> template and how the template uses it. Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Burstah, a build monitor]]></title>
    <link href="https://lplotni.github.io/blog/2015/06/27/build-monitors/"/>
    <updated>2015-06-27T15:41:00+02:00</updated>
    <id>https://lplotni.github.io/blog/2015/06/27/build-monitors</id>
    <content type="html"><![CDATA[<p>During my last four projects or so, the teams I worked with were always using <a href="http://www.go.cd/">GO.CD</a> as the CD tool of their
choosing. Although the pipeline state visualisation GO.CD comes with is quite nice, it still doesn&rsquo;t cut it as a proper,
<em>obvious</em> build monitor enabling everybody in the team to quickly recognize what is the pipeline status.</p>

<p><img class="left" src="/images/burstah_example.png" title="Burstah in action" ></p>

<p>Therefore first <a href="https://github.com/lplotni/cidar">cidar</a>, a simple sinatra based build monitor, has been born. I quickly discovered
that sinatra and especially the nokogiri dependency, doesn&rsquo;t make it easy to use e.g. a Raspberry Pi as the monitor hardware. So,
having the liberty, I decided to re-implement everything in JavaScript using node.js &amp; express. <a href="https://github.com/lplotni/burstah">Burstah</a>
, my second attempt at the ultimative build monitor, has been born  <img alt="bowtie" src="/images/emoji/bowtie.png" class="emoji" /></p>

<!--more-->


<p>All the necessary information how to use, install or contribute can be found in <strong>Burstah</strong>&rsquo;s readme.</p>

<p>Currently <strong>Burstah</strong> has following features:</p>

<ul>
<li>Polling for the cctray.xml to recognize the pipelines and their status</li>
<li>Grabbing the commit details directly out of the GO.CD and presenting them</li>
<li>Providing an animation when the build is running</li>
<li>Supporting emojis in the commit messages <img alt="thumbsup" src="/images/emoji/unicode/1f44d.png" class="emoji" /></li>
</ul>


<p>If you have any wishes or issues, just write stuff down on the <a href="https://github.com/lplotni/burstah/issues">github issues page</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scoopcamp Hackathon]]></title>
    <link href="https://lplotni.github.io/blog/2013/09/14/scoopcamp-hackathon/"/>
    <updated>2013-09-14T13:05:00+02:00</updated>
    <id>https://lplotni.github.io/blog/2013/09/14/scoopcamp-hackathon</id>
    <content type="html"><![CDATA[<p>Last Thursday I was a part of the <a href="http://scoopcamp.de/hackathon/">Scoopcamp hackathon</a> and it was so great that I just couldn&rsquo;t resist to write down some of my thoughts about it. Our team <strong>ThoughtWorks and friends</strong> a colorful mix of journalists, students and developers had a rough idea for a modern - more <strong>agile</strong> - journalism, where the journalist reporting about an ongoing event writes the background story and live updates from his perspective, but can also incorporate content written by the readers who create their own streams representing their own take on the particular event. Being able to see which stream/entry is getting most likes (=feedback), he/she can quickly react and focus on the currently favorite perspective. During a quick brainstorming we came up with the name: <strong>LiquidPub</strong> (for liquid publishing) and started defining the first user stories.</p>

<!-- More -->


<p><img class="right" src="/images/liquidpub_screenshot.png" title="Our app" > To be able to deliver something within less than a day of coding, we went with Ruby on Rails. This gave me the opportunity to finally try out Rails and learn it a bit by pairing with some experienced Ruby/Rails devs. The application itself has been deployed on heroku and being ThoughtWorks we built and deployed it after each push to our <a href="https://github.com/thoughtworks/liquid-pub">github repo</a> using <a href="https://www.snap-ci.com/">snap-ci</a> - <a href="http://martinfowler.com/bliki/ContinuousDelivery.html">continuous delivery</a> FTW!</p>

<p>You can see the result <a href="http://liquid-pub.herokuapp.com/stories/3">here</a>.</p>

<h2>Tech stack</h2>

<ul>
<li>Ruby/Rails + <a href="http://slim-lang.com/">slim</a> (as the templating engine) + <a href="http://foundation.zurb.com/">Foundation</a> CSS lib (for a responsive client)</li>
<li>PostgreSQL</li>
</ul>


<h2>Some stats</h2>

<ul>
<li>4 dev pairs and 1 designer implemented 27 user stories in 6 iterations</li>
<li>I arrived at 8:45 and left around 00:30 (<em>true hackathon sprit! ;)</em>)</li>
<li>91 builds / 145 commits</li>
</ul>


<h2>Wrap-up + My take on Rails</h2>

<p>A day before the hackathon, I got the message that we will do it using Ruby on Rails - so I did not really have a lot of time to look into it. But that was actually no problem at all, as I paired with another guy who had some rails experience. Although I heard it often, I was still amazed how quickly one can set up a CRUD application with it. There is of course a lot of magic happening in the background and when you have some more complicated use cases, you really need to look deeper into the <a href="http://guides.rubyonrails.org/">rails guide</a> or other documentation. My pair and myself had some issues trying to integrate a <a href="https://github.com/galetahub/rails-ckeditor">WYSIWYG editor</a> which was working in the development mode but not in the production mode due to some assets processing problems. This was the only problem we could not solve quickly. For templates we used slim which is definitely nice, but takes some time getting used to. Otherwise Rails provides as I already expected a very nice developer experience. As I am taking a deeper look into <a href="http://www.playframework.com/">Play2.0</a> now, I can try to write the same application to be able to compare the development speed and experience of both frameworks. A blog post will follow&hellip;
This hackathon was really a great opportunity to have fun and meet new people and try out new technologies. I really look forward to another event like this!</p>
]]></content>
  </entry>
  
</feed>
